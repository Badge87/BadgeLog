//
//  FileDestination.swift
//  BadgeLog
//
//  Created by Daniele Bachicchi on 31/01/22.
//

import Foundation

/**
  `LogDestination` that will save the log inside files.
 */
public class FileDestination: LogDestination {
    /**
     The name of the log file.
    */
    let filename: String = "log"
    
    /**
         The path of the folder where the log files will be saved.
         Default is inside `FileManager.default.urls(for: .libraryDirectory, in: .userDomainMask)`/logs/
    */
    let folder = FileManager.default.urls(for: .libraryDirectory, in: .userDomainMask)[0].appendingPathComponent("logs")
    
    /**
     Max number of files that this `LogDestination` will create
    */
    var maxFiles: Int = 2
    
    
    /**
         Max size in MB per single file. When a file reach this size, it will create another file if didn't
         reach `FileDestination.maxFiles`. When `FileDestination.maxFiles` is reached. The older file
         will be overwritten.
         
         This variable is used only if `FileDestination.maxFiles` is greater than 1.
    */
    var maxFilesizeMB = 5
    
    var fileHandle: FileHandle? = nil
    
    public init() {
        super.init()
    }
    
    deinit {
            if let fileHandle = fileHandle {
                fileHandle.closeFile()
            }
        }
    
    override public func send(level: Logger.LogLevel, msg: String, error: NSError?, file: String, function: String, line: Int) -> String {
        let result = super.send(level: level, msg: msg, error: error, file: file, function: function, line: line)
        
        if result.isEmpty {
            return ""
        }
        
        // Create log folder if not exist
        if !FileManager.default.fileExists(atPath: folder.path){
            do  {
                try FileManager.default.createDirectory(atPath: folder.path, withIntermediateDirectories: true)}
            catch {
                print("Error create folder \(folder):\n\(error)")
            }
        }
        
        
        if (maxFiles > 1 && Double(getFileLogSize())/1024.0/1024.0 > Double(maxFilesizeMB)) {
                    rotate()
        }
        
        let saved = saveToFile(str: result)
        
        if !saved {
            print ("Error writing new log row...")
        }
        
        return result
    }
    
    /**
         Return all log files generated by this `FileDestination`.
         
         - Returns:an array of `File` created by this `FileDestination`
    */
    public func getLogFiles() -> [LogFile]{
        var result: [LogFile] = []
        for i in 0...maxFiles {
            let tmp = getFileUrl(index: i)
            if FileManager.default.fileExists(atPath: tmp.path) {
                do {
                    try result.append(LogFile(url: tmp))
                } catch {
                    print("Error generating LogFile \(tmp):\n\(error)")
                }
            }
        }
        return result
    }
    
    private func rotate(){
        var files: [URL] = []
        var file: URL? = nil
        for i in 1...maxFiles {
            let tmp = getFileUrl(index: i)
            if !FileManager.default.fileExists(atPath: tmp.path) {
                do{
                    try FileManager.default.copyItem(at: getFileUrl(), to: tmp)
                    file = tmp
                }catch {
                    print("Error during copy \(getFileUrl()) to \(tmp)")
                }
            } else {
                files.append(tmp)
            }
        }
        
        if file == nil {
            file = files.sorted{fileModificationDate(url: $0) ?? Date.distantFuture < fileModificationDate(url: $1) ?? Date.distantFuture}.first
        }
        
        do{
            var _ = try FileManager.default.replaceItemAt(file!, withItemAt: getFileUrl())
            
        }catch {
            print("Error during copy \(getFileUrl()) to existing f \(String(describing: file))")
        }
        
    }
    
    private func getFileLogSize() -> UInt64{
        do {
            let attr = try FileManager.default.attributesOfItem(atPath: getFileUrl().path)
            return attr[FileAttributeKey.size] as! UInt64
        } catch {
            return 0
        }
        
    }
    func fileModificationDate(url: URL) -> Date? {
        do {
            let attr = try FileManager.default.attributesOfItem(atPath: url.path)
            return attr[FileAttributeKey.modificationDate] as? Date
        } catch {
            return nil
        }
    }
    private func getFileUrl(index: Int = 0) -> URL {
        let suffix = index > 0 ? "\(index)" : ""
        return folder.appendingPathComponent("\(filename)\(suffix).txt")
    }
    
    func saveToFile(str: String) -> Bool {
        let url = getFileUrl()
            do {
                if FileManager.default.fileExists(atPath: url.path) == false {
                    
                    let line = str + "\n"
                    try line.write(to: url, atomically: true, encoding: .utf8)
                } else {
                    if fileHandle == nil {
                        fileHandle = try FileHandle(forWritingTo: url as URL)
                    }
                    if let fileHandle = fileHandle {
                        let _ = fileHandle.seekToEndOfFile()
                        let line = str + "\n"
                        if let data = line.data(using: String.Encoding.utf8) {
                            fileHandle.write(data)
                        }
                    }
                }
                return true
            } catch {
                print("Error writing FileDestination to file \(url):\n\(error).")
                return false
            }
    }
    
}
